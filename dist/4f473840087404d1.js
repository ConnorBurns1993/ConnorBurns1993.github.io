import*as THREE from"three";import*as dat from"lil-gui";import gsap from"gsap";const gui=new dat.GUI,parameters={materialColor:"#ffeded"};gui.addColor(parameters,"materialColor").onChange((()=>material.color.set(parameters.materialColor)));const canvas=document.querySelector("canvas.webgl"),scene=new THREE.Scene,textureLoader=new THREE.TextureLoader,gradientTexture=textureLoader.load("textures/gradients/5.jpg");gradientTexture.magFilter=THREE.NearestFilter;const material=new THREE.MeshToonMaterial({color:parameters.materialColor,gradientMap:gradientTexture}),objectDistance=4,mesh1=new THREE.Mesh(new THREE.TorusGeometry(1,.4,16,60),material),mesh2=new THREE.Mesh(new THREE.ConeGeometry(1,2,32),material),mesh3=new THREE.Mesh(new THREE.TorusKnotGeometry(.8,.35,100,16),material);mesh1.position.y=-0,mesh1.position.x=2,mesh2.position.y=-4,mesh2.position.x=-2,mesh3.position.y=-8,mesh3.position.x=2,scene.add(mesh1,mesh2,mesh3);const sectionMeshes=[mesh1,mesh2,mesh3],particlesCount=200,positions=new Float32Array(600);for(let e=0;e<200;e++)positions[3*e+0]=10*(Math.random()-.5),positions[3*e+1]=2-15*Math.random(),positions[3*e+2]=10*(Math.random()-.5);const particlesGeometry=new THREE.BufferGeometry;particlesGeometry.setAttribute("position",new THREE.BufferAttribute(positions,3));const particlesMaterial=new THREE.PointsMaterial({color:parameters.materialColor,sizeAttenuation:!0,size:.03}),particles=new THREE.Points(particlesGeometry,particlesMaterial);scene.add(particles);const directionalLight=new THREE.DirectionalLight("#ffffff",1);directionalLight.position.set(1,1,0),scene.add(directionalLight);const sizes={width:window.innerWidth,height:window.innerHeight};window.addEventListener("resize",(()=>{sizes.width=window.innerWidth,sizes.height=window.innerHeight,camera.aspect=sizes.width/sizes.height,camera.updateProjectionMatrix(),renderer.setSize(sizes.width,sizes.height),renderer.setPixelRatio(Math.min(window.devicePixelRatio,2))}));const cameraGroup=new THREE.Group;scene.add(cameraGroup);const camera=new THREE.PerspectiveCamera(35,sizes.width/sizes.height,.1,100);camera.position.z=6,cameraGroup.add(camera);const renderer=new THREE.WebGLRenderer({canvas,alpha:!0});renderer.setSize(sizes.width,sizes.height),renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));let scrollY=window.scrollY,currentSection=0;window.addEventListener("scroll",(()=>{scrollY=window.scrollY;const e=Math.round(scrollY/sizes.height);e!=currentSection&&(currentSection=e,gsap.to(sectionMeshes[currentSection].rotation,{duration:1.5,ease:"power.inOut",x:"+=3",y:"+=1.5",z:"+=.75"}))}));const cursor={x:0,y:0};window.addEventListener("mousemove",(e=>{cursor.x=e.clientX/sizes.width-.5,cursor.y=e.clientY/sizes.height-.5,console.log(cursor)}));const clock=new THREE.Clock;let previousTime=0;const tick=()=>{const e=clock.getElapsedTime(),t=e-previousTime;previousTime=e,camera.position.y=-scrollY/sizes.height*4;const i=cursor.x,r=cursor.y;cameraGroup.position.x+=2*(i-cameraGroup.position.x)*t,cameraGroup.position.y+=2*(-r-cameraGroup.position.y)*t;for(const e of sectionMeshes)e.rotation.x+=.1*t,e.rotation.y+=.1*t;renderer.render(scene,camera),window.requestAnimationFrame(tick)};tick();